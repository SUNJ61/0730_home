레이캐스트
장점 : 메모리가 적게 든다.
단점 : 오브젝트를 렌더링 하는 부분을 표현하기 어렵고 
        레이저로 감지하다보니 물리력이 없다. 때문에 스크립트로 물리력을 표현해야한다.

레거시는 메카님과 다르게 원하는 자식 오브젝트만 보이게 하는 기능을 사용할 수 없다.
==================================================================================
오늘 할 것

드럼통을 감지하지 못하고 적들이 돌아오지 않는걸 수정

레이캐스트로 총알 발사 시스템 만들기

==================================================================================

1. 드럼통을 감지하지 못하고 적들이 돌아오지 않는걸 수정
  -드럼통을 택한후 윈도우 ->네비게이션 오브솔레이트를 킨다음 해당 탭 안에 오브젝트 ->네비게이션 스태틱을 전부 체크
  -그후 다시 bake를 하면 해당 오브젝트를 제외한 주변을 돌아다니도록 경로를 수정한다.
   #이것의 문제점. 드럼통이 터져서 날라가도 원래 지점 주변을 피해서간다. 또한 날라가고 떨어진 드럼통을 피해가지 않는다.
    ##즉, 고정된 오브젝트가 아닌 움직임이 있는 오브젝트는 해당 방법을 쓰면 안됨.

  -트럼통에 nav mesh obstacle 컴퍼넌트를 추가하고, 사이즈를 원하는 만큼 조정
  -해당 컴퍼넌트는 해당 오브젝트가 장애물로 인식하게 해주는 컴퍼넌트다.
   #오브젝트가 움직여서 위치가 바뀌더라도 ai가 적용된 오브젝트들은 해당 오브젝트를 피해다닌다.

2. 레이캐스트로 총알 발사 시스템 만들기

   ->FireCtrl수정
   ->EnemyDamage수정
   #총알이 나가는게 보이지 않음. 레이저 렌더러를 넣어서 추후에 눈에 보이게 할 예정.

3. 레이캐스트에서 총알 꼬리 만들기 (라인 렌더러)

  -파이어 포스에 빈 자식오브젝트 생성
  -라인 렌더러 컴퍼넌트 추가
  -world space 사용 해제
  -trail머터리얼 적용, 쏠때마다 껏다켯다 하기.
  -스크립트 제작

4. 드럼통 폭파후 찌그러짐을 표현하기.

  -드럼통 컨트롤 스크립트 수정하기. (메쉬필터 컴포넌트 사용)

5. 플레이어 죽으면 적 춤추기

6.드럼통 틈이 작은데 돌아오지 않는 현상 수정
  -nav 메쉬 오브스타클 carve 옵션 체크 (오브젝트 주변에 bake를 없앤다. 게임이 많이 무거워짐)
  -즉, 게임이 많이 무거워지므로 적 오브젝트가 가까워지면 켰다가 멀어지면 꺼지도록 설게해야한다.

->다음시간에 할것
   ## off mesh link를 사용해본다. ##
   ## Delegate (이벤트 관련 대리자)를 사용해본다. ## 
      -> for문으로 모든 연산을 하는건 오브젝트가 많아지면 딜레이가 생긴다. 이를 해결할수 있는 것이 Delegate이다.
===================================================================================
C#

자료구조 알고리즘 
-> 자료구조 : 데이터를 저장하는 방식
-> 알고리즘 : 저장된 데이터를 처리하는 방식

가변길이 배열 (int[][] jagged = new int[3][] 이렇게 선언함.)
 - ArrayList (유니티에서 잘 사용하지 않음.)
   -> arraylist는 object자료형으로 선언되어서 박싱,언박싱이 발생해 느려져 유니티에서 사용하지 않는다.                                               
 - List
 - Delegate : 이벤트 관련 대리자. (유니티에서 바로 다뤄볼 예정)


컬렉션 : 같은 성격을 가진 데이터의 모음을 담는 자료구조
 ->예시 : ArrayList , Queue, Stack, HashTable이 있다.

ArrayList : 배열과 달리 컬렉션은 생성할 때 용량을 지정하지 않는다. (자동으로 용량이 늘어난다)
              Arraylist에 담는 변수를 object로 선언했기에 모든 자료형을 입력할 수 있다.
              arraylist는 object자료형으로 선언되어서 박싱,언박싱이 발생해 느려져 유니티에서 사용하지 않는다. 

que : 먼저 넣은 값을 꺼낼때도 먼저꺼내는 자료구조. (First in First out : FIFO)
stack : 먼저 넣은 값을 꺼낼때 제일 마지막에 꺼내는 자료구조. (Last in First out : LIFO)
hashtable : 키(Key)와 값(Value)의 쌍으로 이루어진 데이터를 다룰때 쓰인다.

인덱서[indexer]
 ->인덱서는 인덱스를 이용하여 객체내에 데이터에 접근해주는 프로퍼티라고 생각하면 된다.